{"# Code\ndef _listening(self) -> None:\n    self.logger.debug(\"LiveClient._listening ENTER\")\n\n    while True:\n        try:\n            self.lock_exit.acquire()\n            myExit = self.exit\n            self.lock_exit.release()\n            if myExit:\n                self.logger.notice(\"_listening exiting gracefully\")\n                self.logger.debug(\"LiveClient._listening LEAVE\")\n                return\n\n            message = self._socket.recv()\n            if len(message) == 0:\n                self.logger.info(\"message is empty\")\n                continue\n\n            data = json.loads(message)\n            response_type = data.get(\"type\")\n            self.logger.verbose(\"response_type: %s\", response_type)\n\n            match response_type:\n                case LiveTranscriptionEvents.Transcript.value:\n                    self.logger.debug(\n                        \"response_type: %s, data: %s\", response_type, data\n                    )\n                    result = LiveResultResponse.from_json(message)\n                    if result is None:\n                        self.logger.error(\"LiveResultResponse.from_json is None\")\n                        continue\n                    self.logger.verbose(\"result: %s\", result)\n                    self._emit(\n                        LiveTranscriptionEvents.Transcript,\n                        result=result,\n                        **dict(self.kwargs),\n                    )\n                case LiveTranscriptionEvents.Metadata.value:\n                    self.logger.debug(\n                        \"response_type: %s, data: %s\", response_type, data\n                    )\n                    result = MetadataResponse.from_json(message)\n                    if result is None:\n                        self.logger.error(\"MetadataResponse.from_json is None\")\n                        continue\n                    self.logger.verbose(\"result: %s\", result)\n                    self._emit(\n                        LiveTranscriptionEvents.Metadata,\n                        metadata=result,\n                        **dict(self.kwargs),\n                    )\n                case LiveTranscriptionEvents.SpeechStarted.value:\n                    self.logger.debug(\n                        \"response_type: %s, data: %s\", response_type, data\n                    )\n                    result = SpeechStartedResponse.from_json(message)\n                    if result is None:\n                        self.logger.error(\"SpeechStartedResponse.from_json is None\")\n                        continue\n                    self._emit(\n                        LiveTranscriptionEvents.SpeechStarted,\n                        speech_started=result,\n                        **dict(self.kwargs),\n                    )\n                case LiveTranscriptionEvents.UtteranceEnd.value:\n                    self.logger.debug(\n                        \"response_type: %s, data: %s\", response_type, data\n                    )\n                    result = UtteranceEndResponse.from_json(message)\n                    if result is None:\n                        self.logger.error(\"UtteranceEndResponse.from_json is None\")\n                        continue\n                    self.logger.verbose(\"result: %s\", result)\n                    self._emit(\n                        LiveTranscriptionEvents.UtteranceEnd,\n                        utterance_end=result,\n                        **dict(self.kwargs),\n                    )\n                case LiveTranscriptionEvents.Error.value:\n                    self.logger.debug(\n                        \"response_type: %s, data: %s\", response_type, data\n                    )\n                    result = ErrorResponse.from_json(message)\n                    if result is None:\n                        self.logger.error(\"ErrorResponse.from_json is None\")\n                        continue\n                    self.logger.verbose(\"result: %s\", result)\n                    self._emit(\n                        LiveTranscriptionEvents.Error,\n                        error=result,\n                        **dict(self.kwargs),\n                    )\n                case _:\n                    self.logger.warning(\n                        \"Unknown Message: response_type: %s, data: %s\",\n                        response_type,\n                        data,\n                    )\n\n        except websockets.exceptions.ConnectionClosedOK as e:\n            if e.code == 1000:\n                self.logger.notice(\"_listening(1000) exiting gracefully\")\n                self.logger.debug(\"LiveClient._listening LEAVE\")\n                return\n            else:\n                error: ErrorResponse = {\n                    \"type\": \"Exception\",\n                    \"description\": \"Unknown error _listening\",\n                    \"message\": f\"{e}\",\n                    \"variant\": \"\",\n                }\n                self.logger.error(\n                    f\"WebSocket connection closed with code {e.code}: {e.reason}\"\n                )\n                self._emit(LiveTranscriptionEvents.Error, error)\n                self.logger.debug(\"LiveClient._listening LEAVE\")\n                raise\n\n        except Exception as e:\n            error: ErrorResponse = {\n                \"type\": \"Exception\",\n                \"description\": \"Unknown error _listening\",\n                \"message\": f\"{e}\",\n                \"variant\": \"\",\n            }\n            self._emit(LiveTranscriptionEvents.Error, error)\n            self.logger.error(\"Exception in _listening: %s\", str(e))\n            self.logger.debug(\"LiveClient._listening LEAVE\")\n            raise\n\n# Instructions\nExtract code verbatim from the function_to_refactor using EXTRACT sections according to the user request. These extractions will be used later to refactor the code.\n* Choose specific and informative names for these functions under new_function_name.\n* We must copy the code verbatim. Keep whitespace and comments.\n* Extractions must not overlap.\n* Extractions should be removable without breaking the code. For example, they should not break up a try except block. We use rope to refactor, so DO NOT extract any code that contains `continue` or `return`\n* Extracted functions should be at least 2 lines long and at most 25 lines long.\n\nRespond in the following format with XML tags:\n\n<contextual_request_analysis>\nFirst, determine the valid section(s) you want to make more modular. Choose extractions that simplify the overall flow of the code and pass the instructions.\nAnalyze the user request to identify each section of the code that should be extracted.\nFor each new function outline the first and last lines of code that should be extracted.\n</contextual_request_analysis>\n\n<extractions>\n```\n<<<<<<< EXTRACT\nfirst few lines to be extracted from function_to_refactor\n...\nlast few lines to be extracted from function_to_refactor\n>>>>>>>\n...\n```\n</extractions>\n\n<new_function_names>\n\"new_function_name\"\n...\n</new_function_names>:gpt-4": "<contextual_request_analysis>\nThis function can be made more modular by dividing multiple sections of the code that handle specific types of events. These sections are independent and do not overlap, therefore they can be extracted without breaking the code. Here are the sections to be extracted:\n1. Handling of LiveTranscriptionEvents.Transcript.value.\n2. Handling of LiveTranscriptionEvents.Metadata.value.\n3. Handling of LiveTranscriptionEvents.SpeechStarted.value.\n4. Handling of LiveTranscriptionEvents.UtteranceEnd.value.\n5. Handling of LiveTranscriptionEvents.Error.value.\n</contextual_request_analysis>\n\n<extractions>\n```\n<<<<<<< EXTRACT\nmatch response_type:\n    case LiveTranscriptionEvents.Transcript.value:\n        self.logger.debug(\n            \"response_type: %s, data: %s\", response_type, data\n        )\n        result = LiveResultResponse.from_json(message)\n        if result is None:\n            self.logger.error(\"LiveResultResponse.from_json is None\")\n            continue\n        self.logger.verbose(\"result: %s\", result)\n        self._emit(\n            LiveTranscriptionEvents.Transcript,\n            result=result,\n            **dict(self.kwargs),\n        )\n>>>>>>>\n...\n<<<<<<< EXTRACT\n    case LiveTranscriptionEvents.Metadata.value:\n        self.logger.debug(\n            \"response_type: %s, data: %s\", response_type, data\n        )\n        result = MetadataResponse.from_json(message)\n        if result is None:\n            self.logger.error(\"MetadataResponse.from_json is None\")\n            continue\n        self.logger.verbose(\"result: %s\", result)\n        self._emit(\n            LiveTranscriptionEvents.Metadata,\n            metadata=result,\n            **dict(self.kwargs),\n        )\n>>>>>>>\n...\n<<<<<<< EXTRACT\n    case LiveTranscriptionEvents.SpeechStarted.value:\n        self.logger.debug(\n            \"response_type: %s, data: %s\", response_type, data\n        )\n        result = SpeechStartedResponse.from_json(message)\n        if result is None:\n            self.logger.error(\"SpeechStartedResponse.from_json is None\")\n            continue\n        self._emit(\n            LiveTranscriptionEvents.SpeechStarted,\n            speech_started=result,\n            **dict(self.kwargs),\n        )\n>>>>>>>\n...\n<<<<<<< EXTRACT\n    case LiveTranscriptionEvents.UtteranceEnd.value:\n        self.logger.debug(\n            \"response_type: %s, data: %s\", response_type, data\n        )\n        result = UtteranceEndResponse.from_json(message)\n        if result is None:\n            self.logger.error(\"UtteranceEndResponse.from_json is None\")\n            continue\n        self.logger.verbose(\"result: %s\", result)\n        self._emit(\n            LiveTranscriptionEvents.UtteranceEnd,\n            utterance_end=result,\n            **dict(self.kwargs),\n        )\n>>>>>>>\n...\n<<<<<<< EXTRACT\n    case LiveTranscriptionEvents.Error.value:\n        self.logger.debug(\n            \"response_type: %s, data: %s\", response_type, data\n        )\n        result = ErrorResponse.from_json(message)\n        if result is None:\n            self.logger.error(\"ErrorResponse.from_json is None\")\n            continue\n        self.logger.verbose(\"result: %s\", result)\n        self._emit(\n            LiveTranscriptionEvents.Error,\n            error=result,\n            **dict(self.kwargs),\n        )\n>>>>>>>\n...\n```\n</extractions>\n\n<new_function_names>\n\"handle_transcription_event\"\n\"handle_metadata_event\"\n\"handle_speech_start_event\"\n\"handle_utterance_end_event\"\n\"handle_error_event\"\n</new_function_names>"}